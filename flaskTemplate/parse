parser grammar FlaskTemplateParser;

options { tokenVocab = FlaskTemplateLexer; }

@header { package gen; }


//   Program

program
    : programItem* EOF #programRoot
    ;
programItem
    : importStatement   #importItem
    | declaration       #declarationItem
    | functionDecl      #functionItem
    | statement         #statementItem
    | NEWLINE           #newlineItem
    ;




importStatement
    : IMPORT dottedName (COMMA dottedName)* NEWLINE*  #importModule
    | FROM dottedName IMPORT (STAR | dottedName (COMMA dottedName)*) NEWLINE*  #fromImport
    ;

declaration
    : assignment #declarationStmt
    ;

//  Functions

functionDecl
    : decorator* DEF ID LPAREN paramList? RPAREN COLON suite #functionDecleration
    ;


decorator
    : AT dottedName LPAREN argumentList? RPAREN NEWLINE #decoratorRule
    ;

dottedName
    : ID (DOT ID)*
    ;

argumentList
    : NEWLINE* argument NEWLINE*  (NEWLINE* COMMA NEWLINE* argument NEWLINE* )*
    ;

argument
    : ID EQ expression  #keywordArgument
    | expression        #positionalArgument
    ;

paramList
    : ID (COMMA ID)*
    ;

// Expressions


/*
expression
    : expression OR expression
    | expression AND expression
    | NOT expression
    | expression (EQEQ | NOTEQ | GT | LT | LTEQ | GTEQ | IN | IS) expression
    | expression (PLUS | MINUS) expression
    | expression (STAR | SLASH | PERCENT) expression
    | primary
    ;*/

//
expression
    : logicalOrExpression  #expressionRoot
    ;

logicalOrExpression
    : logicalAndExpression (OR logicalAndExpression)*
    ;

logicalAndExpression
    : equalityExpression (AND equalityExpression)*
    ;

equalityExpression
    : comparisonExpression ((EQEQ | NOTEQ) comparisonExpression)*
    ;

comparisonExpression
    : additiveExpression ((LT | LTEQ | GT | GTEQ | IN | IS) additiveExpression)*
    ;

additiveExpression
    : multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*
    ;

multiplicativeExpression
    : unaryExpression ((STAR | SLASH | PERCENT) unaryExpression)*
    ;

/*unaryExpression
    : (PLUS | MINUS | NOT)+ primaryExpression   #multipleUnary
    | primaryExpression                         #simplePrimary
    ;*/
unaryExpression
    : (PLUS | MINUS | NOT) unaryExpression    #unaryOp
    | primaryExpression                       #simplePrimary
    ;

primaryExpression
    : atom (postfix)*
    ;



postfix
    : LBRACK expression RBRACK     #indexExpr
    | DOT ID                       #attrExpr
    | LPAREN argumentList? RPAREN  #callExpr
    ;

// Atom
atom
    : ID                       #idAtom
    | STRING                   #stringAtom
    | INT                      #intAtom
    | FLOAT                    #floatAtom
    | TRUE                     #trueAtom
    | FALSE                    #falseAtom
    | NONE                     #noneAtom
    | listLiteral              #listAtom
    | dictLiteral              #dictAtom
    | setLiteral               #setAtom
    | LPAREN expression RPAREN #parenAtom
    ;


// ----------- list / dict ------------------------

listLiteral
  : LBRACK NEWLINE*
      (expression (COMMA NEWLINE* expression)*)?
    NEWLINE* RBRACK
  ;

dictLiteral
  : LBRACE NEWLINE*
       (dictEntry (COMMA NEWLINE* dictEntry)*)?
    NEWLINE* RBRACE
  ;


dictEntry: expression COLON expression;

setLiteral
  : LBRACE NEWLINE*
        (expression NEWLINE* (COMMA NEWLINE* expression)*)?
    NEWLINE* RBRACE
  ;


//    Statements

statement
    : assignment        #assignmentStmt
    | exprStatement     #exprStmt
    | ifStatement       #ifStmt
    | forStatement      #forStmt
    | returnStatement   #returnStmt
    | passStatement     #passStmt
    | breakStatement    #breakStmt
    | continueStatement #continueStmt
    | globalStatement   #globalStmt
    | withStatement     #withStmt
    ;

breakStatement
    : BREAK NEWLINE?
    ;
continueStatement
    : CONTINUE NEWLINE?
    ;



assignment
    : leftHandSide NEWLINE* assignOp NEWLINE* expression NEWLINE* #assignmentRule
    ;


assignOp
    : EQ
    | PLUSEQ
    | MINUSEQ
    | STAREQ
    | SLASHEQ
    | POWEREQ
    | FLOORDIVEQ
    | BITANDEQ
    | BITOREQ
    ;

leftHandSide
    : primaryExpression
    ;

exprStatement
    : expression
    ;

ifStatement
    : IF expression COLON suite
      (ELIF expression COLON suite)*
      (ELSE COLON suite)?
      #ifStatementRule
    ;


forStatement
    : FOR ID IN expression COLON suite  #forStatementRule
    ;


returnStatement
    : RETURN expression?
    ;

passStatement
    : PASS
    ;



// ----------- Blocks ---------------------

suite
    : braceBlock  #braceSuite
    | indentBlock #indentSuite
    ;

braceBlock
    : NEWLINE* LBRACE NEWLINE*
      statement (NEWLINE+ statement)*
      NEWLINE* RBRACE NEWLINE*
    ;

indentBlock
    : NEWLINE INDENT
      statement (NEWLINE+ statement)*
      DEDENT
    ;




/*simpleStatement
    : (assignment | exprStatement | returnStatement | passStatement) NEWLINE?
    ;*/

globalStatement
    : GLOBAL ID (COMMA ID)* NEWLINE?
    ;


withStatement
            : WITH expression (AS ID)? COLON suite  #withStatementRule
            ;




//----------------------------------------
parser grammar TemplateParser;

options {
    tokenVocab = FlaskTemplateLexer;
}

template
        : (doctype? html NEWLINE*)+ EOF #templateRoot
        ;

doctype: HTML_DOCTYPE;

html: HTML_TAG_OPEN HTML_ID htmlAttributes TAG_CLOSE templateContent TEMPLATE_END       #htmlDocument
    ;

templateContent
    : contentItem*
    ;
contentItem
    : htmlElement   # htmlContent
    | jinjaBlock    # jinjaBlockContent
    | jinjaExpr     # jinjaExprContent
    | htmlText      # htmlTextContent
    | cssStyle      # cssContent
    | NEWLINE       # newlineContent
    ;


htmlElement:
    openingTag (templateContent)? closingTag      # normalElement
    | voidTag                                     # voidElementTag
    | selfClosingTag                              # selfClosingElementTag
    ;

openingTag: HTML_TAG_OPEN HTML_ID htmlAttributes TAG_CLOSE #openingTagNode
          ;

closingTag: HTML_TAG_OPEN_SELF HTML_ID TAG_CLOSE #closingTagNode
          ;

selfClosingTag: HTML_TAG_OPEN HTML_ID htmlAttributes SELF_CLOSE_TAG;

voidTag: HTML_TAG_OPEN VOID_TAG htmlAttributes TAG_CLOSE;

htmlAttributes
            : htmlAttribute*  #htmlAttributeList
            ;

htmlAttribute
    : HTML_ID HTML_EQ htmlAttributeValue     # attributeWithValue
    | HTML_BOOLEAN_ATTR                         # booleanAttribute
    ;


htmlAttributeValue
    : HTML_QUOTE    attrValueContent? ATTR_VALUE_QUOTE     # doubleQuotedValue
    | HTML_APOSTROPHE attrValueContent? ATTR_VALUE_APOSTROPHE  # singleQuotedValue
    ;


attrValueContent
    : attrValueItem*
    ;

attrValueItem
    : ATTR_VALUE_ID   # attrText
    | attrJinjaExpr   # attrJinjaExprItem
    | attrJinjaBlock  # attrJinjaBlockItem
    ;


/*
attrJinjaExpr : ATTR_JINJA_EXPR_START expression EXPR_END ;
*/


attrJinjaExpr
    : ATTR_JINJA_EXPR_START attrJinjaExprContent /*jinjaExpression*/ EXPR_END
    ;
attrJinjaExprContent
    : (.)*?
    ;


attrJinjaBlock
    : ATTR_JINJA_BLOCK_START jinjaBlockStatement BLOCK_END
    ;


htmlText: HTML_TEXT;

// Jinja2 Blocks
jinjaBlock:
    TEMPLATE_JINJA_BLOCK_START jinjaBlockStatement BLOCK_END  #jinjaBlockNode
    ;

jinjaBlockStatement:
    BLOCK_EXTENDS BLOCK_STRING                                        # extendsBlock
    | BLOCK_BLOCK BLOCK_ID                                            # blockStart
    | BLOCK_ENDBLOCK                                                  # blockEnd
    | BLOCK_IF blockExpression                                        # ifStart
    | BLOCK_ELIF blockExpression                                      # elifBlock
    | BLOCK_ELSE                                                      # elseBlock
    | BLOCK_ENDIF                                                     # ifEnd
    | BLOCK_FOR BLOCK_ID BLOCK_IN blockExpression                     # forStart
    | BLOCK_ENDFOR                                                    # forEnd
    | BLOCK_SET BLOCK_ID BLOCK_EQ blockExpression                     # setBlock
    | BLOCK_INCLUDE BLOCK_STRING                                      # includeBlock
    | BLOCK_IMPORT BLOCK_STRING (BLOCK_AS BLOCK_ID)?                  # importBlock
    | BLOCK_FROM BLOCK_STRING BLOCK_IMPORT importList                 # fromImportBlock
    | BLOCK_WITH blockExpression                                      # withStart
    | BLOCK_ENDWITH                                                   # withEnd
    | BLOCK_ID (BLOCK_EQ blockExpression)?                            # genericBlock
    ;

blockExpression
    : blockLogicalOrExpression
    ;

blockLogicalOrExpression
    : blockLogicalAndExpression (BLOCK_OR blockLogicalAndExpression)*
    ;

blockLogicalAndExpression
    : blockEqualityExpression (BLOCK_AND blockEqualityExpression)*
    ;

blockEqualityExpression
    : blockComparisonExpression ((BLOCK_EQEQ | BLOCK_NEQ) blockComparisonExpression)*
    ;

blockComparisonExpression
    : blockAdditiveExpression ((BLOCK_LT | BLOCK_LTE | BLOCK_GT | BLOCK_GTE | BLOCK_IN | BLOCK_IS) blockAdditiveExpression)*
    ;

blockAdditiveExpression
    : blockMultiplicativeExpression ((BLOCK_PLUS | BLOCK_MINUS) blockMultiplicativeExpression)*
    ;

blockMultiplicativeExpression
    : blockUnaryExpression ((BLOCK_STAR | BLOCK_SLASH | BLOCK_PERCENT) blockUnaryExpression)*
    ;

blockUnaryExpression
    : (BLOCK_PLUS | BLOCK_MINUS | BLOCK_NOT) blockUnaryExpression #blockUnaryOp
    | blockPrimaryExpression                                      #blockUnaryBase
    ;


blockPrimaryExpression
    : blockAtom (blockPostfix)*  #blockPrimary
    ;

blockAtom
    : BLOCK_LPAREN blockExpression BLOCK_RPAREN         #blockParenExpr
    | BLOCK_ID                                         #blockIdentifier
    | BLOCK_STRING                                     #blockStringLiteral
    | BLOCK_NUMBER                                     #blockNumberLiteral
    | BLOCK_TRUE                                       #blockTrueLiteral
    | BLOCK_FALSE                                      #blockFalseLiteral
    | BLOCK_NONE                                       #blockNoneLiteral
    | BLOCK_LBRACK blockExpressionList? BLOCK_RBRACK   #blockListLiteral
    | BLOCK_LBRACE blockDictPairList? BLOCK_RBRACE     #blockDictLiteral
    ;

blockPostfix
    : BLOCK_PIPE BLOCK_ID blockArgumentList?  #blockFilterOp
    | BLOCK_LPAREN blockArgumentList? BLOCK_RPAREN   #blockCallOp
    | BLOCK_DOT BLOCK_ID                           #blockMemberOp
    ;

blockArgumentList
    : blockExpression (BLOCK_COMMA blockExpression)*
    ;

blockExpressionList
    : blockExpression (BLOCK_COMMA blockExpression)*
    ;

blockDictPairList
    : blockDictPair (BLOCK_COMMA blockDictPair)*
    ;

blockDictPair
    : BLOCK_STRING BLOCK_COLON blockExpression
    ;





importList: BLOCK_ID (BLOCK_COMMA BLOCK_ID)*;

// Jinja2 Expressions
jinjaExpr:
    TEMPLATE_JINJA_EXPR_START jinjaExpression EXPR_END
    ;

jinjaExpression: expression;

expression
        : logicalOrExpression #expressionRoot
        ;

logicalOrExpression
                : logicalAndExpression (EXPR_OR logicalAndExpression)*
                ;

logicalAndExpression
                : equalityExpression (EXPR_AND equalityExpression)*
                ;

equalityExpression
                : comparisonExpression ((EXPR_EQEQ | EXPR_NEQ) comparisonExpression)*
                ;

comparisonExpression
                : additiveExpression ((EXPR_LT | EXPR_LTE | EXPR_GT | EXPR_GTE | EXPR_IN | EXPR_IS) additiveExpression)*
                ;

additiveExpression
                : multiplicativeExpression ((EXPR_PLUS | EXPR_MINUS) multiplicativeExpression)*
                ;

multiplicativeExpression
                    : unaryExpression ((EXPR_STAR | EXPR_SLASH | EXPR_PERCENT | EXPR_FLOORDIV) unaryExpression)*
                    ;

unaryExpression
            : (EXPR_PLUS | EXPR_MINUS | EXPR_NOT)? primaryExpression
            ;

primaryExpression
    : EXPR_LPAREN expression EXPR_RPAREN                             # parenExpr
    | EXPR_ID (EXPR_DOT EXPR_ID)*                                    # identifierExpr
    | EXPR_ID EXPR_LPAREN argumentList? EXPR_RPAREN                  # callExpr
    | EXPR_STRING                                                    # stringExpr
    | EXPR_NUMBER                                                    # numberExpr
    | EXPR_TRUE                                                      # trueExpr
    | EXPR_FALSE                                                     # falseExpr
    | EXPR_NONE                                                      # noneExpr
    | EXPR_LBRACK expressionList? EXPR_RBRACK                        # listExpr
    | EXPR_LBRACE dictPairList? EXPR_RBRACE                          # dictExpr
    | primaryExpression EXPR_PIPE EXPR_ID argumentList?              # filterExpr
    ;

argumentList
            : expression (EXPR_COMMA expression)* #argList
            ;
expressionList
            : expression (EXPR_COMMA expression)* #exprList
            ;
dictPairList
           : dictPair (EXPR_COMMA dictPair)* #dictPairListNode
           ;
dictPair: EXPR_STRING EXPR_COLON expression;

// CSS Blocks
cssStyle
    : CSS_START cssTagAttributes? CSS_TAG_CLOSE cssStyleContent STYLE_TAG_END # styleWithAttributes
    | CSS_START CSS_TAG_CLOSE cssStyleContent STYLE_TAG_END                   # styleWithoutAttributes
    ;

cssTagAttributes: cssTagAttribute+;
cssTagAttribute: CSS_TAG_ATTR CSS_TAG_EQ CSS_TAG_STRING;

cssStyleContent
            : cssStyleItem*
            ;
cssStyleItem
    : cssRule           #cssRuleItem
    | CSS_CONTENT_COMMENT #cssCommentItem
    ;
cssRule
      : cssSelectors CSS_LBRACE cssDeclarations CSS_RBRACE
      ;

cssSelectors
            : cssSelector (CSS_COMMA cssSelector)*   #cssSelectorExpr
            ;

//  CSS
cssSelector: (CSS_CONTENT | CSS_CLASS | CSS_ID)+;

cssDeclarations
              : cssDeclaration*  #cssDeclarationList
              ;

cssDeclaration
            : CSS_PROPERTY CSS_COLON cssValues CSS_SEMICOLON
            ;

cssValues
        : cssValue (CSS_COMMA? cssValue)* #cssValueList
        ;

cssValue
    : CSS_STRING     #cssStringValue
    | CSS_NUMERIC    #cssNumericValue
    | CSS_COLOR      #cssColorValue
    | CSS_KEYWORD    #cssKeywordValue
    ;